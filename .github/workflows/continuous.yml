name: Continuous Release

on:
  workflow_call:
    inputs:
      tag:
        required: true
        type: string
      name:
        required: true
        type: string
      body:
        required: true
        type: string

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          merge-multiple: true

      - name: List artifacts
        run: |
          find . -type f

      - name: Create or update continuous release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          RELEASE_SHA: ${{ github.sha }}
          RELEASE_TAG: ${{ inputs.tag }}
          RELEASE_NAME: ${{ inputs.name }}
          RELEASE_BODY: ${{ inputs.body }}
        run: |
          # Check for existing tag
          ep="/repos/{owner}/{repo}/git/ref/tags/$RELEASE_TAG"
          tag_err=0; tag=$(gh api "$ep") || tag_err=$?

          # Check for existing release
          ep="/repos/{owner}/{repo}/releases/tags/$RELEASE_TAG"
          release_err=0; release=$(gh api "$ep") || release_err=$?

          if [ "$release_err" -ne 0 ]; then
            # Check for existing draft release, preferring the first one found
            ep="/repos/{owner}/{repo}/releases"
            release_err=0; release=$(gh api "$ep" | jq -e "[.[] | select(.tag_name == \"$RELEASE_TAG\")].[0]") || release_err=$?
          fi

          if [ "$tag_err" -eq 0 ]; then
            # Delete tag (will be recreated on correct commit)
            # Deleting changes the corresponding release to a draft
            echo "deleting existing tag:"; echo "$tag" | jq '.'
            ep="/repos/{owner}/{repo}/git/refs/tags/$RELEASE_TAG"
            gh api -X DELETE "$ep"
          fi

          if [ "$release_err" -eq 0 ]; then
            # Delete assets from existing release
            echo "deleting assets from existing release:"; echo "$release" | jq '.'
            ep="/repos/{owner}/{repo}/releases/assets"
            for asset_id in $(echo "$release" | jq -r '.assets[].id'); do
              gh api -X DELETE "$ep/$asset_id"
            done

            # Prepare to update existing release
            release_id=$(echo "$release" | jq -r '.id')
            ep="/repos/{owner}/{repo}/releases/$release_id"
            method="PATCH"

          else
            # Prepare to create a new release
            ep="/repos/{owner}/{repo}/releases"
            method="POST"
          fi

          # Create or update release
          release=$(gh api -X "$method" "$ep" \
            -f "tag_name=$RELEASE_TAG" \
            -f "target_commitish=$RELEASE_SHA" \
            -f "name=$RELEASE_NAME" \
            -f "body=$RELEASE_BODY" \
            -F "draft=true" \
            -F "prerelease=true")
          echo "current release:"; echo "$release" | jq '.'

          # Upload assets
          url=$(echo "$release" | jq -r '.upload_url' | cut -d '{' -f 1)
          for file in $(find . -type f); do
            echo "uploading $file"
            asset_err=0; asset=$(curl --fail-with-body -L -X POST \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@$file" \
              "$url?name=$(basename $file | jq -Rr @uri)") || asset_err=$?
            echo "uploaded asset:"; echo "$asset" | jq '.'
            [ "$asset_err" -eq 0 ] || exit "$asset_err"
          done

          # Publish release, will create tag
          release_id=$(echo "$release" | jq -r '.id')
          ep="/repos/{owner}/{repo}/releases/$release_id"
          release=$(gh api -X PATCH "$ep" -F "draft=false")
          echo "published release:"; echo "$release" | jq '.'
